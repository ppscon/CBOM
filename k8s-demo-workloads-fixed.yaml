# QVS-CBOM Demo Workloads - Fixed Version
# Stable containers for demo purposes

apiVersion: v1
kind: Namespace
metadata:
  name: cbom
  labels:
    purpose: qvs-cbom-testing
---
# Simple Python app that generates RSA keys and stays running
apiVersion: apps/v1
kind: Deployment
metadata:
  name: python-crypto-demo
  namespace: cbom
spec:
  replicas: 1
  selector:
    matchLabels:
      app: python-crypto
  template:
    metadata:
      labels:
        app: python-crypto
    spec:
      containers:
      - name: python-crypto
        image: python:3.9-slim
        command: ["/bin/bash"]
        args: 
        - "-c"
        - |
          pip install cryptography > /dev/null 2>&1
          python -c "
          from cryptography.hazmat.primitives.asymmetric import rsa
          from cryptography.hazmat.primitives import serialization
          
          # Generate RSA key
          key = rsa.generate_private_key(65537, 2048)
          print('RSA-2048 key generated successfully')
          
          # Generate ECDSA key
          from cryptography.hazmat.primitives.asymmetric import ec
          ec_key = ec.generate_private_key(ec.SECP256R1())
          print('ECDSA P-256 key generated successfully')
          
          # Keep running
          import time
          while True:
              print('Crypto demo running...')
              time.sleep(300)
          "
        env:
        - name: RSA_KEY_SIZE
          value: "2048"
        - name: CRYPTO_ALGORITHM
          value: "RSA-PKCS1"
---
# Node.js crypto demo
apiVersion: apps/v1
kind: Deployment
metadata:
  name: node-crypto-demo
  namespace: cbom
spec:
  replicas: 1
  selector:
    matchLabels:
      app: node-crypto
  template:
    metadata:
      labels:
        app: node-crypto
    spec:
      containers:
      - name: node-crypto
        image: node:16-alpine
        command: ["/bin/sh"]
        args:
        - "-c"
        - |
          node -e "
          const crypto = require('crypto');
          
          // Generate RSA key pair
          const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
            modulusLength: 2048,
          });
          console.log('RSA-2048 key pair generated');
          
          // Generate ECDSA key pair
          const { publicKey: ecPublic, privateKey: ecPrivate } = crypto.generateKeyPairSync('ec', {
            namedCurve: 'secp256r1',
          });
          console.log('ECDSA P-256 key pair generated');
          
          // Keep running
          setInterval(() => {
            console.log('Node crypto demo running...');
          }, 300000);
          
          // Keep process alive
          process.stdin.resume();
          "
---
# Java crypto demo with JDK
apiVersion: apps/v1
kind: Deployment
metadata:
  name: java-crypto-demo
  namespace: cbom
spec:
  replicas: 1
  selector:
    matchLabels:
      app: java-crypto
  template:
    metadata:
      labels:
        app: java-crypto
    spec:
      containers:
      - name: java-crypto
        image: openjdk:11-jdk-slim
        command: ["/bin/bash"]
        args:
        - "-c"
        - |
          cat > CryptoDemo.java << 'EOF'
          import java.security.*;
          import javax.crypto.*;
          import java.security.spec.*;
          
          public class CryptoDemo {
              public static void main(String[] args) throws Exception {
                  // Generate RSA key pair
                  KeyPairGenerator rsaGen = KeyPairGenerator.getInstance("RSA");
                  rsaGen.initialize(2048);
                  KeyPair rsaKeys = rsaGen.generateKeyPair();
                  System.out.println("RSA-2048 key pair generated");
                  
                  // Generate ECDSA key pair
                  KeyPairGenerator ecGen = KeyPairGenerator.getInstance("EC");
                  ecGen.initialize(256);
                  KeyPair ecKeys = ecGen.generateKeyPair();
                  System.out.println("ECDSA P-256 key pair generated");
                  
                  // Generate AES key
                  KeyGenerator aesGen = KeyGenerator.getInstance("AES");
                  aesGen.init(256);
                  SecretKey aesKey = aesGen.generateKey();
                  System.out.println("AES-256 key generated");
                  
                  // Keep running
                  while (true) {
                      System.out.println("Java crypto demo running...");
                      Thread.sleep(300000); // 5 minutes
                  }
              }
          }
          EOF
          
          javac CryptoDemo.java
          java CryptoDemo
---
# ConfigMap with TLS and crypto configurations
apiVersion: v1
kind: ConfigMap
metadata:
  name: tls-config
  namespace: cbom
  annotations:
    crypto.algorithms: "RSA-2048,ECDHE,AES-256,SHA-256"
    tls.version: "1.2,1.3"
data:
  nginx.conf: |
    server {
      listen 443 ssl http2;
      ssl_certificate /etc/ssl/certs/server.crt;
      ssl_certificate_key /etc/ssl/private/server.key;
      ssl_protocols TLSv1.2 TLSv1.3;
      ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384;
      ssl_prefer_server_ciphers on;
      ssl_session_timeout 5m;
      ssl_session_cache shared:SSL:50m;
    }
  crypto-config.yml: |
    encryption:
      algorithm: "AES-256-CBC"
      key_derivation: "PBKDF2"
      hash_function: "SHA-256"
      key_size: 256
    signing:
      algorithm: "RSA-PSS"
      key_size: 2048
      hash: "SHA-256"
    key_exchange:
      algorithm: "ECDH"
      curve: "P-256"
      hash: "SHA-256"
---
# Secret with base64 encoded crypto keys
apiVersion: v1
kind: Secret
metadata:
  name: crypto-keys
  namespace: cbom
  annotations:
    crypto.types: "RSA,ECDSA,AES"
    key.sizes: "2048,256,256"
type: Opaque
data:
  # RSA private key (properly base64 encoded)
  rsa-private.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcEFJQkFBS0NBUUVBdGhVWld6Z3g4cFBVQldUMXN1cERhZXY3YnJMckVmMXpOT2RNUXF2c1dOc0lOCnFVOENkVE5HbHdGcmppb2M5WVhOTnFjTHJaTjB4Z0dWNjhpUmRrQ1VVekljcWxtUVVnYWtyMEJaMXkzS2QKMTBaS0t3UXVYWFo3bms0TUJrTWhJRGFnZXdRQVBTVDJ6clBCdGdGaFlSUFlpQjBaOFE0WXNoWVZGCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==
  # ECDSA public key (properly base64 encoded)
  ecdsa-public.key: LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFVjE5VklRNE1xVDhZNzNJaUYyWVJ5QzRrCjYxa1VMUU5YOUVsSWM1NGVCdll1WkUyMGU2SWRCZ2FxaUEyZ0gzd1RNUDZPQmlFeVFqSXhlRwotLS0tLUVORCBQVUJMSUMgS0VZLS0tLS0K
  # AES key (256-bit key properly base64 encoded)
  aes-256-key: MTIzNDU2Nzg5MEFCQ0RFRjEyMzQ1Njc4OUFCQ0RFRjEyMzQ1Njc4OUFCQ0RFRg==
---
# Service with crypto annotations
apiVersion: v1
kind: Service
metadata:
  name: crypto-service
  namespace: cbom
  annotations:
    service.beta.kubernetes.io/azure-load-balancer-internal: "true"
    crypto.algorithm: "RSA-2048"
    crypto.key-exchange: "ECDHE"
    tls.version: "1.2"
    cipher.suite: "AES-256-GCM"
spec:
  selector:
    app: python-crypto
  ports:
  - name: https
    port: 8443
    targetPort: 8443
    protocol: TCP
  - name: http
    port: 8080
    targetPort: 8080
    protocol: TCP
  type: LoadBalancer
---
# Ingress with TLS configuration
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: crypto-ingress
  namespace: cbom
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-protocols: "TLSv1.2 TLSv1.3"
    nginx.ingress.kubernetes.io/ssl-ciphers: "ECDHE-RSA-AES256-GCM-SHA384"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - crypto-demo.example.com
    secretName: crypto-tls-secret
  rules:
  - host: crypto-demo.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: crypto-service
            port:
              number: 8080